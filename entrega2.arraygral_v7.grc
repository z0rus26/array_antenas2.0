options:
  parameters:
    author: ''
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: arraygeneral
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: arraygeneral
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 8]
    rotation: 0
    state: enabled

blocks:
- name: D
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ''
    label: D
    min_len: '200'
    orient: QtCore.Qt.Horizontal
    rangeType: float
    start: '0'
    step: 4/100
    stop: '4'
    value: '.4'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [809, 270]
    rotation: 0
    state: true
- name: N
  id: variable
  parameters:
    comment: ''
    value: len(posiciones)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [571, 51]
    rotation: 0
    state: enabled
- name: excitaciones
  id: variable
  parameters:
    comment: ''
    value: w_magnitudes*np.exp(1j*w_fases)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [807, 141]
    rotation: 0
    state: enabled
- name: phi_apuntar_gr
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ''
    label: phi_apuntar_gr
    min_len: '200'
    orient: QtCore.Qt.Horizontal
    rangeType: float
    start: '0'
    step: '1'
    stop: '180'
    value: '0'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [845, 396]
    rotation: 0
    state: true
- name: po
  id: variable
  parameters:
    comment: ''
    value: ruta3d.receiver_path(128)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [389, 9]
    rotation: 0
    state: enabled
- name: posiciones
  id: variable
  parameters:
    comment: ''
    value: antenna_tools.posiciones_arreglo_planar(4,4,D)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [811, 206]
    rotation: 0
    state: enabled
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: '32000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [180, 6]
    rotation: 0
    state: enabled
- name: theta_apuntar_gr
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ''
    label: theta_apuntar_gr
    min_len: '200'
    orient: QtCore.Qt.Horizontal
    rangeType: float
    start: '0'
    step: '1'
    stop: '180'
    value: '0'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [699, 395]
    rotation: 0
    state: true
- name: w_fases
  id: variable
  parameters:
    comment: ''
    value: antenna_tools.calcularFasesApuntamiento(phi_apuntar_gr*np.pi/180,theta_apuntar_gr*np.pi/180,
      posiciones)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [805, 78]
    rotation: 0
    state: enabled
- name: w_magnitudes
  id: variable
  parameters:
    comment: ''
    value: np.array([1]*N)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [806, 8]
    rotation: 0
    state: enabled
- name: analog_const_source_x_0
  id: analog_const_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    const: '1'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: complex
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [17, 132]
    rotation: 0
    state: true
- name: antenna_tools
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "# Aqui se reunen una serie de funciones que puede ser de utilidad\
      \ en la definicion o configuracion de arreglos de antenas\n\nimport numpy as\
      \ np\nimport scipy.integrate as integrate\nimport scipy.interpolate as interp\n\
      ###############################################################################\n\
      ##     Funciones utiles para el direcionamiento del patron del arreglo     \
      \  ##\n###############################################################################\n\
      # Para apuntar el patron de un arreglo a una direccion phi,theta, es necesario\
      \ conocer las fases\n# de con las que se debe alimentar a los radiadores. Para\
      \ eso se usa la funcion calcularFasesApuntamiento()\n# de la siguiente manera:\n\
      # * Llama esta funcion por ejemplo asi:w_apuntar=calcularFasesApuntamiento(phi,theta,posiciones)\n\
      # * ve a tu arreglo y muliplica las exitaciones por w_apuntar\n# Nota: la version\
      \ del profe Binomi se diferencia de esta en que entrega las exponenciales complejas\n\
      # nos pareci\xF3 m\xE1s claro para ususario que se entregen las fases solamente.\n\
      def calcularFasesApuntamiento(phi,theta, posiciones):\n    normal = np.array((np.cos(phi)*np.sin(theta),np.sin(phi)*np.sin(theta),np.cos(theta)))\n\
      \    fases = -2*np.pi*posiciones@normal\n    return fases\n    \n###############################################################################\n\
      ##                 Funciones utiles para las aperturas                     \
      \  ##\n###############################################################################\n\
      def amplitudCosElev(posiciones,escala=0.8):\n    centro = np.mean(posiciones,axis=0)\n\
      \    desplazamientos = posiciones-centro\n    radios = np.linalg.norm(desplazamientos,axis=1)\n\
      \    rmax=np.max(radios)\n    A = 1+np.cos(np.pi*escala*radios/rmax)\n    return\
      \ A/np.linalg.norm(A)*A.size**.5\n    \n#distintos patrones de radiacion para\
      \ elementos. Ver ejemplo de arreglo lineal abajo para su uso\n###############################################################################\n\
      ##     Patrones de radiacion que pueden ser usados en los radiadores       \
      \  ##\n###############################################################################\n\
      \ndef patron1():\n    # Patron arbitrario generado a partir de tabla\n    if\
      \ (\"patron\" not in dir(patron1)):\n        #angulosTheta = np.linspace(0,180,91)*np.pi/180\n\
      \        angulosTheta = np.array([0,30,60,90,120,150,180])*np.pi/180\n     \
      \   intensidadesRel = np.array([1e-3,1,1.2,2,.3,.1,0])\n        #intensidadesRel\
      \ = np.array([8,8.1,8,6.1,4.1,2.1,5])\n        f_denorm = interp.interp1d(angulosTheta,intensidadesRel,kind=\"\
      cubic\")\n        # potenciaMedia = integrate.dblquad(lambda fi,th: f_denorm(th)**2*np.sin(th),0,np.pi,-np.pi,np.pi)[0]/(4*np.pi)\n\
      \        # Por haber simetria respecto al eje z, la integral se reduce a\n \
      \       potenciaMedia = integrate.quad(lambda th: f_denorm(th)**2*np.sin(th),0,np.pi)[0]/2\n\
      \        escala = 1/potenciaMedia**.5 # para normalizar a potencia media 1\n\
      \        def patron(phi,theta):\n            return escala*f_denorm(theta)\n\
      \        patron1.patron = patron\n    return patron1.patron\n\ndef parche_sat():\n\
      \    # Patron de la antena parche para el satelite de proy\n    \n    # la tabla\
      \ de valores que representa al patron desde 0 hasta 180 grados\n    angulosTheta\
      \ = np.linspace(0,180,91)*np.pi/180\n    intensidadesRel =np.array([3.9,4,4.1,4.2,4.3,4.2,4.25,4.2,4.1,4.05,4,3.95,3.95,\n\
      \        4,4.05,4.15,4.1,4.1,4.1,4.1,4.05,3.95,3.9,\n        3.85,3.8,3.8,3.9,3.95,4,4,4.05,4,4,4,3.9,3.85,\n\
      \        3.8,3.8,3.75,3.6,3.55,3.45,3.35,3.25,3.15,3.05,3,\n        2.85,2.7,2.65,2.6,2.6,2.6,2.6,2.6,2.6,2.5,2.5,2.45,\n\
      \        2.35,2.2,2.15,1.9,1.9,1.95,2,1.9,1,1,1.7,2.1,2.3,2.35,\n        2.25,2,1,1,1.8,2.1,2,1.8,1,2.1,2.5,2.55,2.5,2,1,0.5,2.2,2.45])\n\
      \    \n    # La interpolacion\n    f_denorm = interp.interp1d(angulosTheta,intensidadesRel,kind=\"\
      cubic\")\n    potenciaMedia = integrate.quad(lambda th: f_denorm(th)**2*np.sin(th),0,np.pi)[0]/2\n\
      \    escala = 1/potenciaMedia**.5 # para normalizar a potencia media 1\n   \
      \ \n    # el patron para cualquier phi, theta\n    def patron(phi,theta):\n\
      \        return escala*f_denorm(theta)\n    parche_sat.patron = patron\n   \
      \ return parche_sat.patron\n    \ndef patronDipoloCorto():\n    if (\"patron\"\
      \ not in dir(patronDipoloCorto)):\n        f_denorm = np.sin\n        #simetria\
      \ axial, eje z\n        potenciaMedia = integrate.quad(lambda th: f_denorm(th)**2*np.sin(th),0,np.pi)[0]/2\n\
      \        escala = 1/potenciaMedia**.5 # para normalizar a potencia media 1\n\
      \        def patron(phi,theta):\n            return escala*f_denorm(theta)\n\
      \        patronDipoloCorto.patron = patron\n    return patronDipoloCorto.patron\n\
      def patronDipoloMediaOnda():\n    self = patronDipoloCorto\n    if (\"patron\"\
      \ not in dir(self)):\n        epsilon = 1e-6\n        def f_denorm(theta):\n\
      \            theta=np.array(theta)\n            determinado = (theta > epsilon)\
      \ & ((np.pi-theta) > epsilon)\n            result = np.zeros(theta.shape)\n\
      \            theta_determinado = theta[determinado]\n            result[determinado]\
      \ = np.cos(np.pi/2*np.cos(theta_determinado))/np.sin(theta_determinado) \n \
      \           return result\n        #simetria axial, eje z\n        potenciaMedia\
      \ = integrate.quad(lambda th: f_denorm(th)**2*np.sin(th),0,np.pi)[0]/2\n   \
      \     escala = 1/potenciaMedia**.5 # para normalizar a potencia media 1\n  \
      \      def patron(phi,theta):\n            return escala*f_denorm(theta)\n \
      \       self.patron = patron\n    return self.patron\ndef patronMonopoloCuartoOnda():\n\
      \    self = patronMonopoloCuartoOnda\n    if (\"patron\" not in dir(self)):\n\
      \        epsilon = 1e-6\n        def f_denorm(theta):\n            theta=np.array(theta)\n\
      \            determinado = (theta > epsilon) & (theta <= np.pi/2)\n        \
      \    result = np.zeros(theta.shape)\n            theta_determinado = theta[determinado]\n\
      \            result[determinado] = np.cos(np.pi/2*np.cos(theta_determinado))/np.sin(theta_determinado)\
      \ \n            return result\n        #simetria axial, eje z\n        potenciaMedia\
      \ = integrate.quad(lambda th: f_denorm(th)**2*np.sin(th),0,np.pi)[0]/2\n   \
      \     escala = 1/potenciaMedia**.5 # para normalizar a potencia media 1\n  \
      \      def patron(phi,theta):\n            return escala*f_denorm(theta)\n \
      \       self.patron = patron\n    return self.patron\n\n#def pmcoka(phi,theta):\n\
      #    pmcoi=patronMonopoloCuartoOnda()\n#    p=pmcoi(phi,theta)\n#    return\
      \ p\n##################################################################\n##\
      \   Varias configuraciones de posiciones para arreglos         ##\n##################################################################\n\
      #     Arreglo planar\n# permite obtener las posiciones para un arreglo planar\n\
      # organizado de manera que vemos Nx filas y Ny columnas\n# de manera que hay\
      \ N=Nx x Ny radiadores y todos est\xE1n distanciados\n# de sus vecinos en una\
      \ distand D x lambda\n# las posiciones se entregan en forma de un vector de\
      \ N elementos.\n\ndef posiciones_arreglo_planar(Nx,Ny, D):\n    return D*np.array([(x,y,0)\
      \ for x in range(Nx) for y in range(Ny)])\n    \ndef posiciones_arreglo_esferico(Nx,Ny,D):\n\
      \    cx=(Nx-1)/2\n    cy=(Ny-1)/2\n    return D*np.array([(x,y,np.sqrt(2*max(cx,cy)**2-(x-cx)**2-(y-cy)**2))\
      \ for x in range(Nx) for y in range(Ny)])\n\ndef posiciones_arreglo_cilindro(Nx,Ny,D):\n\
      \    cx = (Nx-1)/2\n    return D*np.array([(x,y,np.sqrt(2*cx**2-(x-cx)**2))\
      \ for x in range(Nx) for y in range(Ny)])\n\ndef posiciones_arreglo_linealz(Nz,Dz):\n\
      \    return Dz*np.array([(0,0,z) for z in range(Nz)])\ndef posiciones_arreglo_sat_viejo():\n\
      \    # Todas las distancias estan en lambdas\n    # Bl el largo del panel solar\n\
      \    # Ba el ancho del panel solar\n    # D distancia entre radiadores de la\
      \ parte basica\n    Bl=3\n    Ba=1\n    antena11=np.array([Ba/2, Bl,0])\n  \
      \  antena12=np.array([-Ba/2, Bl,0])\n    antena13=np.array([Ba/2, Bl-Ba,0])\n\
      \    antena14=np.array([-Ba/2, Bl-Ba,0])\n    arreglo1=np.array([antena11,antena12,antena13,antena14])\n\
      \    return arreglo1    \n\n\ndef posiciones_arreglo_sat_ladoyp(Nx,Ny,D):\n\
      \    # radiadores en el eje y parte positiva\n    a1=posiciones_arreglo_planar(Nx,Ny,D)\n\
      \    # lo siguiente es para correr el array del centro para despejar el\n  \
      \  # espacio que ocupa el cubo del satelite\n    a1=a1+np.array([-D/2,1.5*D,0])\n\
      \    return a1    \n\ndef posiciones_arreglo_sat_ladoydoble(Nx,Nypos,D):\n \
      \   # radiadores en el eje y a ambos lados\n    # Nypos, es el numero de elementos\
      \ solo en el lado y positivo\n    a1=posiciones_arreglo_sat_ladoyp(Nx,Nypos,D)\n\
      \    a2=a1+np.array([0,-(Nypos+2)*D,0])\n    return np.concatenate((a1,a2))\n\
      \ndef posiciones_arreglo_sat_ladoxp(Nx,Ny,D):\n    a1=posiciones_arreglo_planar(Nx,Ny,D)\n\
      \    # lo siguiente es para correr el array del centro para despejar el\n  \
      \  # espacio que ocupa el cubo del satelite\n    a1=a1+np.array([1.5*D,-D/2,0])\n\
      \    return a1    \ndef posiciones_arreglo_sat_ladoxdoble(Nxpos,Ny,D):\n   \
      \ # radiadores en el eje y a ambos lados\n    # Nypos, es el numero de elementos\
      \ solo en el lado y positivo\n    a1=posiciones_arreglo_sat_ladoxp(Nxpos,Ny,D)\n\
      \    a2=a1+np.array([-(Nxpos+2)*D,0,0])\n    return np.concatenate((a1,a2))\
      \ \n\ndef posiciones_arreglo_sat_full(Nx,Ny,D):\n   a1=posiciones_arreglo_sat_ladoydoble(Nx,Ny,D)\n\
      \   a2=posiciones_arreglo_sat_ladoxdoble(Ny,Nx,D)\n   return np.concatenate((a1,a2))\
      \ \n   #return a1\n   \n \n\n   \n   #return np.concatenate((a1,a2)) \n    \
      \  \n\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [275, 56]
    rotation: 0
    state: true
- name: blocks_complex_to_mag_0
  id: blocks_complex_to_mag
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [125, 430]
    rotation: 0
    state: enabled
- name: blocks_multiply_xx_0
  id: blocks_multiply_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_inputs: '2'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [509, 173]
    rotation: 0
    state: true
- name: blocks_stream_to_vector_0
  id: blocks_stream_to_vector
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_items: po.L_path
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [292, 432]
    rotation: 0
    state: true
- name: blocks_throttle_0_0_0
  id: blocks_throttle
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    ignoretag: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_second: samp_rate
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [584, 183]
    rotation: 0
    state: enabled
- name: blocks_vector_source_x_0
  id: blocks_vector_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    repeat: 'True'
    tags: '[]'
    type: float
    vector: po.phi_path()
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [12, 183]
    rotation: 0
    state: enabled
- name: blocks_vector_source_x_0_0
  id: blocks_vector_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    repeat: 'True'
    tags: '[]'
    type: float
    vector: po.theta_path()
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [10, 261]
    rotation: 0
    state: enabled
- name: blocks_vector_source_x_0_1
  id: blocks_vector_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    repeat: 'True'
    tags: '[]'
    type: complex
    vector: ([1]*N)
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [338, 279]
    rotation: 0
    state: enabled
- name: epy_block_0
  id: epy_block
  parameters:
    _source_code: "\nimport numpy as np\nfrom gnuradio import gr\n\n\nclass blk(gr.sync_block):\
      \  # other base classes are basic_block, decim_block, interp_block\n    \"\"\
      \"Hecho por Homero Ortega Boada con la tutoria y de Fernando Alberto Miranda\
      \ Binomi.\n   Arreglo tridimensional de fuentes puntuales con radiadores isotropicos.\n\
      \n   Parametros y senales:\n   * Por In0 entra la envolvente compleja de la\
      \ senal a ser transmitida.\n   * Por In1 y In2 llega la posicion actual del\
      \ receptor en coordenadas esfericas. In1 para phi, In2 para theta\n   * La salida\
      \ es la senal que entra por In0 pero afectada por su paso atraves del arreglo\n\
      \   * posiciones: es un vector de longitud N, el cual contiene las posiciones\
      \ en el espacio 3d de los N radiadores que componen el arreglo. Solo hay que\
      \ tener en cuenta que cada posicion consta de 3 elementos que representan las\
      \ coordenadas x,y,x. Por eso, desde el punto de vista de todos los datos, \"\
      posiciones\" es una matrix N x 3\n   * excitaciones: Es el vector de longitud\
      \ N que contiene las exitaciones para cada uno de los N radiadores. Usualmente\
      \ esos valores son coplejos, donde la magnitud impacta a la apertura del arreglo,\
      \ mientras que las fases impactan la direccionalidad del patron. Si no se desea\
      \ impactar nada de eso, las excitaciones puede ser un vector de puros unos.\n\
      \   \n   Nota: es posible usar este bloque para obtener el patron del arreglo\
      \ teniendo en cuenta lo siguiente:\n   * se senal en In0 puede ser igual a 1,\
      \ pero solo para mejorar la velocidad del calculo\n   * las senales In1, In2\
      \ deben representar la ruta, en angulos phi, theta, que el receptor realiza,\
      \ como si se tratara de un drone que va volando al rededor del arreglo mientras\
      \ mide el campo, hasta cubrir todos esos angulos.   \n   \n   Nota para disenadores:\
      \ este bloque es una evolucion del bloque e_array_general_cc con el fin de lograr\
      \ soluciones mas modulares y mas sencillas, de manera mas acorde con la vision\
      \ de GNU Radio. La simplicidad se logron teniendo en cuenta que hay varias cosas\
      \ que pueden ser realizadas por otros bloques externos, entres esas cosas estan:\n\
      \   * En la practica los radiadores son casi siempre de patron similar, En ese\
      \ caso, un bloque externo puede hacer el ajuste correspondiente para considerar\
      \ la forma de ese patron.\n   * La directividad y la densidad de potencia. Son\
      \ parametros que son mas del interes de un sistema de medicion que de un sistema\
      \ de tiempo real.  \n    \"\"\"\n\n    def __init__(self, posiciones=0,excitaciones=1):\
      \  \n        gr.sync_block.__init__(\n            self,\n            name='e_array_iso_cc',\
      \   \n            in_sig=[np.complex64, np.float32, np.float32],\n         \
      \   out_sig=[np.complex64]\n        )\n        self.posiciones = posiciones\n\
      \        self.excitaciones = excitaciones\n        \n    def _campo_dirUnica(self,phi_i,theta_i):\n\
      \        # normal es el vector que aparece en formula Maillou que senala la\
      \ direccion de observacion\n        normal = np.array((np.cos(phi_i)*np.sin(theta_i),np.sin(phi_i)*np.sin(theta_i),np.cos(theta_i)))\n\
      \        # @ es para que se surta el producto matricial porque el uso de * seria\
      \ un producto punto o escalar\n        fases = 2*np.pi*self.posiciones@normal\n\
      \        return sum(self.excitaciones*np.exp(1j*fases))\n \n    def campo(self,phi,theta):\n\
      \        campo_vec = np.vectorize(self._campo_dirUnica)\n        return campo_vec(phi,theta)\n\
      \        \n    def work(self, input_items, output_items):\n        s=input_items[0]\n\
      \        theta=input_items[2]\n        phi=input_items[1]\n        e=output_items[0]\n\
      \        e[:]=self.campo(phi,theta)\n        return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    excitaciones: excitaciones
    maxoutbuf: '0'
    minoutbuf: '0'
    posiciones: posiciones
  states:
    _io_cache: '(''e_array_iso_cc'', ''blk'', [(''posiciones'', ''0''), (''excitaciones'',
      ''1'')], [(''0'', ''complex'', 1), (''1'', ''float'', 1), (''2'', ''float'',
      1)], [(''0'', ''complex'', 1)], ''Hecho por Homero Ortega Boada con la tutoria
      y de Fernando Alberto Miranda Binomi.\n   Arreglo tridimensional de fuentes
      puntuales con radiadores isotropicos.\n\n   Parametros y senales:\n   * Por
      In0 entra la envolvente compleja de la senal a ser transmitida.\n   * Por In1
      y In2 llega la posicion actual del receptor en coordenadas esfericas. In1 para
      phi, In2 para theta\n   * La salida es la senal que entra por In0 pero afectada
      por su paso atraves del arreglo\n   * posiciones: es un vector de longitud N,
      el cual contiene las posiciones en el espacio 3d de los N radiadores que componen
      el arreglo. Solo hay que tener en cuenta que cada posicion consta de 3 elementos
      que representan las coordenadas x,y,x. Por eso, desde el punto de vista de todos
      los datos, "posiciones" es una matrix N x 3\n   * excitaciones: Es el vector
      de longitud N que contiene las exitaciones para cada uno de los N radiadores.
      Usualmente esos valores son coplejos, donde la magnitud impacta a la apertura
      del arreglo, mientras que las fases impactan la direccionalidad del patron.
      Si no se desea impactar nada de eso, las excitaciones puede ser un vector de
      puros unos.\n   \n   Nota: es posible usar este bloque para obtener el patron
      del arreglo teniendo en cuenta lo siguiente:\n   * se senal en In0 puede ser
      igual a 1, pero solo para mejorar la velocidad del calculo\n   * las senales
      In1, In2 deben representar la ruta, en angulos phi, theta, que el receptor realiza,
      como si se tratara de un drone que va volando al rededor del arreglo mientras
      mide el campo, hasta cubrir todos esos angulos.   \n   \n   Nota para disenadores:
      este bloque es una evolucion del bloque e_array_general_cc con el fin de lograr
      soluciones mas modulares y mas sencillas, de manera mas acorde con la vision
      de GNU Radio. La simplicidad se logron teniendo en cuenta que hay varias cosas
      que pueden ser realizadas por otros bloques externos, entres esas cosas estan:\n   *
      En la practica los radiadores son casi siempre de patron similar, En ese caso,
      un bloque externo puede hacer el ajuste correspondiente para considerar la forma
      de ese patron.\n   * La directividad y la densidad de potencia. Son parametros
      que son mas del interes de un sistema de medicion que de un sistema de tiempo
      real.  \n    '', [''excitaciones'', ''posiciones''])'
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [247, 140]
    rotation: 0
    state: enabled
- name: epy_block_0_1_0_0_0
  id: epy_block
  parameters:
    L_path: po.L_path
    _source_code: "from mpl_toolkits import mplot3d\nimport numpy as np\nfrom gnuradio\
      \ import gr\nimport matplotlib.pyplot as plt\n\nclass polar_graf_f(gr.sync_block):\n\
      \    \"\"\"\nHecho por Homero Ortega Boada. Universidad Industrial de Santander.\n\
      Permite mostrar las graficas m\xE1s relevantes para un arreglo de antenas como:\n\
      * La distribuci\xF3n en 3d de los componentes del arreglo con su respectiva\
      \ alimentaci\xF3n\n* Las alimentaciones que cada componente (radiador) tiene.\n\
      * grafica polar del patron de arreglo con coordenadas esfericas. Las graficas\
      \ las hacemos con herramientas externas a GNU Radio ya que al momento no sabiamos\
      \ como hacerlo de otra manera. Los parametros de entrada son:\n\n* samp_rate:\
      \ es la frecuencia de muestreo en Hz que nunca falta en GNURadio. Influye en\
      \ la velocidad de la grafica, supuestamente se los valores de medicion del \
      \ campo llegan con esa rata\n* Rmax sirve para definir los limites de la grafica,\
      \ se supone que es el m\xE1ximo valor que puede llegar a tomar el campo en magnitud\n\
      * phi: son los valores unicos usados en la grafica para phi. Usualmente phi\
      \ es un vector de valores entre 0 y 2pi con un cierto paso angular\ntheta: son\
      \ los valores unicos usados en la grafica. Usualmente phi es un vector de valores\
      \ entre 0 y pi con el mismo paso angular que phi. De manera que este vector\
      \ tiene 2 veces menos valores que phi\n* posiciones: vector que contiene la\
      \ posicion de cada uno de los componentes del arreglo\n* excitaciones: vector\
      \ que contiene la alimentacion para cada uno de los componentes del arreglo\n\
      * La senal que entra al bloque corresponde a las mediciones de campo realizadas\
      \  para todos los posibles ubicaciones angulares que se puede lograr con las\
      \ combinaciones de phi y theta\n*L_path: es el numero de puntos que tiene la\
      \ ruta. Es la longitud de la ruta\n\nNota: Hemos pretendido que el patron se\
      \ pueda redibujar en tiempo real para nuevas situaciones. Por ejemplo, que si\
      \ en cierto momento cambia la alimentacion de los elementos de radiacion que\
      \ entonces el patron se redibuje adotando la nueva forma. Pero tenemos un problema\
      \ que nos frena y es la manera en que funcionan las graficas 3d de matplotlib.\
      \ Toca buscar alternativas para lograrlo. \n\nRetos para mejorar: es mas natural\
      \ que el bloque pueda identifcar phi y theta a partir de las senals que aporta\
      \ la ruta, es decir, usando las mismas senales que usa el bloque e_polar_graf_3d_p_f\n\
      \"\"\"\n    def __init__(self,samp_rate=32000,phi=0,theta=0, posiciones=0, excitaciones=0,\
      \ L_path=8192):\n        gr.sync_block.__init__(self,\n            name=\"e_vector_antenna_graf_f\"\
      ,\n            in_sig=[(np.float32,L_path)],\n            out_sig=None)\n  \
      \          \n        # Parametros\n        self.L_path=L_path              \
      \     \n        self.Tsamp=1./samp_rate\n        self.contador=0\n        self.phi=phi\n\
      \        self.theta=theta\n        self.posiciones=posiciones\n        self.excitaciones=excitaciones\n\
      \        self.ax1=None\n        self.ax2=None\n               \n    # Canvas\
      \ para graficar el patron solo\n    def canvas_3d_patron(self,):\n        fig=plt.figure()\n\
      \        ax2=fig.add_subplot(1,1,1, projection='3d')\n        ax2.set_xlabel('x')\n\
      \        ax2.set_ylabel('y')\n        ax2.set_zlabel('z')\n        ax2.set_title(\"\
      Patron de radiacion del arreglo\")\n        return ax2\n        \n    # Canvas\
      \ para graficar el array con alimentacion y el patron\n    def canvas_3d_alimentacion_y_patron(self,\
      \ ):\n        fig=plt.figure()\n        ax1=fig.add_subplot(1,2,1, projection='3d')\n\
      \        ax1.set_title(\"El Arreglo-sus elementos y alimentacion\")\n      \
      \  ax1.set_xlabel('x')\n        ax1.set_ylabel('y')\n        ax1.set_zlabel('z')\n\
      \n        ax2=fig.add_subplot(1,2,2, projection='3d')\n        ax2.set_xlabel('x')\n\
      \        ax2.set_ylabel('y')\n        ax2.set_zlabel('z')\n        ax2.set_title(\"\
      Patron de radiacion del arreglo\")\n        return ax1,ax2\n\n    # Traduccion\
      \ de coordenadas esfericas a cartecianas\n    def esferica2cartesiana(self,phi,theta,R):\n\
      \        x = R * np.cos(phi) * np.sin(theta)\n        y = R * np.sin(phi) *\
      \ np.sin(theta)\n        z = R * np.cos(theta)\n        return(x,y,z)      \
      \                             \n\n    def graficaExcitaciones(self,ax=None):\n\
      \        \n        def sep_xyz(filas_xyz):\n            return (filas_xyz[:,0],filas_xyz[:,1],filas_xyz[:,2])\n\
      \                \n        pmin=self.posiciones.min()\n        pmax=self.posiciones.max()\n\
      \        lims = (pmin-(pmax-pmin)*.1,pmax+(pmax-pmin)*.1)\n\n        ax.plot3D(*sep_xyz(self.posiciones),'or')\n\
      \        Emax=np.abs(self.excitaciones).max()\n        if self.posiciones.shape[0]>1:\n\
      \            dmin=min((np.linalg.norm(x-y) for x in self.posiciones for y in\
      \ self.posiciones if np.linalg.norm(x-y) >0))\n            factor = .618*dmin/Emax\n\
      \        else:\n            factor = 1\n            lims = (-1,1)\n        ax.quiver(*sep_xyz(self.posiciones),self.excitaciones.real*factor,self.excitaciones.imag*factor,np.zeros(self.excitaciones.shape))\n\
      \        ax.set_xlim(*lims)\n        ax.set_ylim(*lims)\n        ax.set_zlim(*lims)\n\
      \        \n    def work(self, input_items, output_items):\n        # Inicialmente\
      \ se deben crear 3 matrices de NringsxNang:\n        # * PHI\n        # * THETA\n\
      \        # * R\n        # Nrings: es el numero de filasy equivale al numero\
      \ de anillos en la graf 3d\n        # Nang: es el numero de columnas y a la\
      \ vez de puntos por cada anillo de la graf 3d\n        R_path=input_items[0][0]\
      \ \n        M_patterns=len(input_items[0]) # numero de patrones recibidos\n\
      \        Nang=len(self.phi) \n        Nrings=len(self.theta)\n        PHI,THETA=np.meshgrid(self.phi,self.theta)\n\
      \        R=R_path.reshape(Nrings,Nang)\n        Rmax=np.max(R)\n        X,Y,Z=self.esferica2cartesiana(PHI,THETA,R)\n\
      \                \n        # El if  es porque el canva solo se dibuna una vez\
      \ y no hemos logrado que se haga\n        # dentro del constructor.\n      \
      \  if self.contador == 0:\n            self.contador=1\n            # definimos\
      \ el canvas por una unica vez\n            #self.ax2=self.canvas_3d_patron()\
      \ # cuando queremos ver solo el patron\n            self.ax1,self.ax2=self.canvas_3d_alimentacion_y_patron()\n\
      \n        # Finalmente se ordena la grafica de los valores en X,Y,Z  \n    \
      \    #ax2.plot_wireframe(X,Y,Z)\n\n        self.ax1.cla()\n        self.ax1.set_title(\"\
      El Arreglo-sus elementos y alimentacion\")\n        self.ax1.set_xlabel('x')\n\
      \        self.ax1.set_ylabel('y')\n        self.ax1.set_zlabel('z')\n      \
      \  self.graficaExcitaciones(self.ax1)\n        \n        self.ax2.cla()    \
      \    \n        self.ax2.set_xlabel('x')\n        self.ax2.set_ylabel('y')\n\
      \        self.ax2.set_zlabel('z')\n        self.ax2.set_title(\"Patron de radiacion\
      \ del arreglo\")\n\n        self.ax2.plot_surface(X,Y,Z,cmap=\"coolwarm\")\n\
      \        plt.pause(self.Tsamp)\n                \n        return len(input_items[0])\n"
    affinity: ''
    alias: 3d_f
    comment: ''
    excitaciones: excitaciones
    maxoutbuf: '0'
    minoutbuf: '0'
    phi: po.phi
    posiciones: posiciones
    samp_rate: samp_rate
    theta: po.theta
  states:
    _io_cache: "('e_vector_antenna_graf_f', 'polar_graf_f', [('samp_rate', '32000'),\
      \ ('phi', '0'), ('theta', '0'), ('posiciones', '0'), ('excitaciones', '0'),\
      \ ('L_path', '8192')], [('0', 'float', 8192)], [], '\\nHecho por Homero Ortega\
      \ Boada. Universidad Industrial de Santander.\\nPermite mostrar las graficas\
      \ m\xE1s relevantes para un arreglo de antenas como:\\n* La distribuci\xF3n\
      \ en 3d de los componentes del arreglo con su respectiva alimentaci\xF3n\\n*\
      \ Las alimentaciones que cada componente (radiador) tiene.\\n* grafica polar\
      \ del patron de arreglo con coordenadas esfericas. Las graficas las hacemos\
      \ con herramientas externas a GNU Radio ya que al momento no sabiamos como hacerlo\
      \ de otra manera. Los parametros de entrada son:\\n\\n* samp_rate: es la frecuencia\
      \ de muestreo en Hz que nunca falta en GNURadio. Influye en la velocidad de\
      \ la grafica, supuestamente se los valores de medicion del  campo llegan con\
      \ esa rata\\n* Rmax sirve para definir los limites de la grafica, se supone\
      \ que es el m\xE1ximo valor que puede llegar a tomar el campo en magnitud\\\
      n* phi: son los valores unicos usados en la grafica para phi. Usualmente phi\
      \ es un vector de valores entre 0 y 2pi con un cierto paso angular\\ntheta:\
      \ son los valores unicos usados en la grafica. Usualmente phi es un vector de\
      \ valores entre 0 y pi con el mismo paso angular que phi. De manera que este\
      \ vector tiene 2 veces menos valores que phi\\n* posiciones: vector que contiene\
      \ la posicion de cada uno de los componentes del arreglo\\n* excitaciones: vector\
      \ que contiene la alimentacion para cada uno de los componentes del arreglo\\\
      n* La senal que entra al bloque corresponde a las mediciones de campo realizadas\
      \  para todos los posibles ubicaciones angulares que se puede lograr con las\
      \ combinaciones de phi y theta\\n*L_path: es el numero de puntos que tiene la\
      \ ruta. Es la longitud de la ruta\\n\\nNota: Hemos pretendido que el patron\
      \ se pueda redibujar en tiempo real para nuevas situaciones. Por ejemplo, que\
      \ si en cierto momento cambia la alimentacion de los elementos de radiacion\
      \ que entonces el patron se redibuje adotando la nueva forma. Pero tenemos un\
      \ problema que nos frena y es la manera en que funcionan las graficas 3d de\
      \ matplotlib. Toca buscar alternativas para lograrlo. \\n\\nRetos para mejorar:\
      \ es mas natural que el bloque pueda identifcar phi y theta a partir de las\
      \ senals que aporta la ruta, es decir, usando las mismas senales que usa el\
      \ bloque e_polar_graf_3d_p_f\\n', ['L_path', 'excitaciones', 'phi', 'posiciones',\
      \ 'theta'])"
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [457, 390]
    rotation: 0
    state: enabled
- name: import_0
  id: import
  parameters:
    alias: ''
    comment: ''
    imports: import numpy as np
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [565, 8]
    rotation: 0
    state: true
- name: ruta3d
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "# Lo que hace este programa es lo siguiente:\n# * calcula todos\
      \ los valores angulares en los que un\n# receptor se debe ubicar con el fin\
      \ de poder \n# medir todos los valores de campo y con todo eso\n# poder graficar\
      \ el patron de radiacion en 3d\n# * A diferencia de lo que se hace en la programacion\n\
      # tradicional, donde se dice que phi tiene unos valore\n# entre 0 y 360 grados\
      \ y theta entre 0 y 180, aqui, por usar\n# programacion de tiempo real hay que\
      \ imaginar que tomamos un dron\n# y le pre-programos toda la ruta que hay que\
      \ seguir para \n# sea posible obtener todos los datos del patron de radiacion\n\
      # de un arreglo\n#\n# Como se usa:\n# * supongamos que Ud desea que la ruta\
      \ se haga que tenga Nang=128 puntos angulares por cada anilo\n# Entonces crea\
      \ el objeto po=receiver_path(128) . Nota Nang debe ser tipo 2 a la m\n# * puede\
      \ obtener los valores unicos de phi como po.phi\n# * los de theta como po.theta\n\
      # * los valores que phi para toda la ruta como po.phi_path()\n# * los valores\
      \ que theta para toda la ruta como po.theta_path()\n# * tambien se puede acceder\
      \ al numero de anillos que la grafica\n# tendra en el eje z como po.Nrings\n\
      # * igualmente, el numero de puntos de cada anillo po.Nang\n# * y el numero\
      \ de puntos de toda la ruta po.L_path\n\nimport numpy as np\n\ndef zerooh(x,Sps):\n\
      \    Lx=len(x)\n    g=np.array([x[0]]*Sps)\n    for i in range(1,Lx):\n    \
      \    g=np.concatenate((g,np.array([x[i]]*Sps)))\n    return g\n\nclass receiver_path(object):\n\
      \    def __init__(self, Nang):\n        self.Nang=Nang\n        self.Nrings=int(Nang/2)\n\
      \        self.pasoAngular=360/Nang\n        self.L_path=Nang*self.Nrings\n \
      \       self.phi=np.linspace(0,360,Nang)*np.pi/180\n        self.theta=np.linspace(0,180,self.Nrings)*np.pi/180\n\
      \      \n    # calculo de los valores de phi para todo el recorrido        \
      \    \n    def phi_path(self,):\n        return(np.tile(self.phi, self.Nrings))\n\
      \n    # calculo de los valores de theta para todo el recorrido\n    def theta_path(self,):\n\
      \        return(zerooh(self.theta,self.Nang))\n\n\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [273, 9]
    rotation: 0
    state: true
- name: virtual_sink_0
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: out1
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [734, 255]
    rotation: 270
    state: true
- name: virtual_source_0
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: out1
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [13, 426]
    rotation: 0
    state: enabled

connections:
- [analog_const_source_x_0, '0', epy_block_0, '0']
- [blocks_complex_to_mag_0, '0', blocks_stream_to_vector_0, '0']
- [blocks_multiply_xx_0, '0', blocks_throttle_0_0_0, '0']
- [blocks_stream_to_vector_0, '0', epy_block_0_1_0_0_0, '0']
- [blocks_throttle_0_0_0, '0', virtual_sink_0, '0']
- [blocks_vector_source_x_0, '0', epy_block_0, '1']
- [blocks_vector_source_x_0_0, '0', epy_block_0, '2']
- [blocks_vector_source_x_0_1, '0', blocks_multiply_xx_0, '1']
- [epy_block_0, '0', blocks_multiply_xx_0, '0']
- [virtual_source_0, '0', blocks_complex_to_mag_0, '0']

metadata:
  file_format: 1
